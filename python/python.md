Python:
	√енераторы:
1) ќсновное их преимущество это возможность сохранени€ состо€ни€ после вызова, (в отличие от return, который завершает выполнение функции)
¬ результате чего например: дл€ чисел фибоначи не нужно самому держать в пам€ти последние 2 числа, т.к. в генераторе итак сохран€етс€ состо€ние. ј теперь представь что нибудь более массивное чем фукци€ фибоначи, где множество параметров, нужно держать в пам€ти (без ручного сохранени€)
2) [ѕам€ть] ¬ычисление значений на лету, в результате ты можешь высислить огромные список данных, а на выходе у теб€ будет лишь объект генератор (конечно в котором хранитс€ как вычилс€ть значени€). » только в момент когда эти данные тебе необходимы, они будут вычисл€тьс€.
“ак например: у теб€ на входе огромный массив данных, если использовать return, то при вычислении, ты в пам€ть так же загружаешь выходные данные (V_sum = Input_data + Output_data). ј дл€ yield у теб€ на выходе объект генератор. ¬ходные данные можно уже выгрузить (очистить) из пам€ти. » потом вычислить выходные данные (V_sum = Input_data/Output_data)
3) Ѕлагодар€ этому они используютс€ в асинхронном программ. (сохранение состо€ни€)
4) [ѕам€ть] »за того, что генератор рассчитываетс€ на лету, можно сгенерировать неограниченный массив данных и по нему проитерироватьс€ и при этом не нужно его хранить в пам€ти
